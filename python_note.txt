
python是一种拥有高级数据结构的，以简单为一切出发点的编程语言。可快速开发程序框架，可胶连其他语言。

random.choice(list)
一:常量:数字和字符串

1,数字:整数,浮点数,复数
2.字符串: 字符串一旦创建,不可改变
单引号,双引号,三引号,反斜杠,原始字符串,字符串拼接,格式化输出
用原始字符串编写正则表达式

二:变量
变量的命名
变量无需声明
变量可存储可变数据类型
类型转换

显式行合并,隐式行合并

三:运算符:+ - * ** / // %   位运算:<< >> & | ~ ^ 比较:< > <= >= == != 
逻辑运算:not and or ..... 顺序:lambda or and not in/not in is/is no
**a,b=0,1;a,b=b,a+b; 先计算,后赋值

四:流程控制
1.python没有switch语句
2.if elif else
3.while else
4.for 
5.break continu 仅作用于一层循环
五:函数
调用函数,不带括号,仅返回函数自身,带括号才会运行 

形参和实参,局部变量,全局变量(global) 非局部(nonlocal)
默认实参值,仅放在定义的最后边(是一种字典)

可变参数,*args多余的参数被放入args这个元组中,**dic多余的参数放入dic字典中
可用*解封元组,也可用**解封字典
pass,return,None
文档字符串__doc__ :   help(ma) == print(ma.__doc__)
返回值,以tuple形式返回多值
函数的副作用(本身没有什么用，但产生了其他效果，如print（）)

六.模块
1.导入,重载,卸载
import;   import imp;imp.reload(); del


七.输入输出
格式化输出

基本数据类型
Boolean,None,数字,字符串,字节


高级数据类型
列表,元组,集合,字典

空列表[] 空元组(,) 空集合set() 空字典{}
list function:append(),pop(),popleft(),insert(index,'sth'),remove('sth'),
reverse()


遍历:
dictionary: for key,value in dic.items():
sequence: for i,v in enumerate(list)
list:  for i in list:
操作:增删改

tuple和string一旦赋值,无法更改 

序列包括列表,字符串,元组
序列的特征是支持成员的索引操作和从属测试,切片操作
slice [start:end:pace]

元组
元素不能包含特殊符号,可包含任何数据类型

一种特殊的方法可以将函数的形参当做元组或字典，那就是分别使用*和**前缀

集合包含无序不重复元素,集合不能包含列表,字典,集合,可
包含元组,数字,字符串,True,False,None

集合支持从属操作in /not in
合集| 交集& 差集-    非交集^


set(a_list)从列表产生集合

类与继承:
给类定义一个方法时.必须在第一个位置添加一个self实参
类的构造函数与析构函数__init__  __del__
可在类体外定义类的函数

异常处理
try raise expect else finally
with 可自动打开资源,释放资源

eval exec 将字符串中的字符当作命令来执行

assert 断言,若为False则fatal error

repr() 获得对象得正规字符串表示


dictionary 只能逐个访问key的value 只能由key找到value
+ - * / // ** % 
complex(1,1)=1+1j
a.real a.imag abs(a)
x=y=z=0
float() int()
the last printed expression is assigned to "_"
raw string ''' """
if elif .... 替代switch或case
for i in list和range 替代其他语言步进的写法
if "a" in list:
list.append list.pop list.popleft
列表推导式
vec=[2,3,4] [3*x for x in vec]
[[x,x**2] for x in vec if x>3]
python string couldn't be changed
nest list
高级数据类型：
序列(字串，列表，元组),集合,字典

import imp
imp.reload(module)
del module

from math import *
import this //zen of python

进制赋值 //0x22



sys.path 是一个目录名称的列表，它构成了当前的搜索路径
内置模块使用起来和常规模块一样，但是无法取得它们的 Python 源代码，因为它们不是用 Python 写的！（ sys 模块是用 c 语言写的。）
 sys.path.insert(0, new_path)，你可以插入一个新的目录到 sys.path 列表的第一项，从而使其出现在 Python 搜索路径的开头,获得最高优先级
 一个函数，就像 Python 里面所有其他东西一样，是一个对象。

 Python 里面的 import 就像 Perl 里面的 require。一旦你导入（import）了一个 Python 模块，你就可以通过 module.function 的方式访问它的函数；一旦你要求（require）了一个 Perl 模块，你就可以通过 module::function 的方式访问它的函数。

 Python 里面的所有东西都是对象，所有东西都可以有属性和方法。所有函数都有一个内置的属性 __doc__，用来返回这个函数的源代码里面定义的文档字符串（docstring）

 在 Python 里面所有东西都是对象。字符串是对象，列表是对象，函数是对象，类是对象，类的实例是对象，甚至模块也是对象。
 Python 使用回车符来分割语句，使用一个冒号和缩进来分割代码块
  Python 鼓励对异常的使用，你可以对它进行处理。

当一个错误发生在 Python Shell 里面的时候，它会打印一些关于这个异常以及它如何发生的详细信息，就此而已。这个被称之为一个 未被处理 的异常。在这个异常被抛出的时候，没有代码注意到并处理它，因此它把它的路径冒出来，返回到 Python Shell 的最顶层，输出一些调试信息，然后圆满结束。在这个 Shell 中，这没什么大不了的，但是如果在你的实际 Python 程序正在运行的时候发生，并且对这个异常没有做任何处理的话，整个程序就会嘎的一声停下来

一个异常不会造成整个程序崩溃。不过，异常是可以被处理的

如果你知道某行代码可能抛出一个异常，你应该使用 try...except 块来处理这个异常。
使用 raise 语句，紧跟着异常的名称，和一个人们可以读取的字符串用来调试。这个语法让人想起调用的函数。（实际上，异常是用类来实现的，这个 raise 语句事实上正在创建一个 ValueError 类的实例并传递一个字符串 'number must be non-negative' 到它的初始化方法里面
其中一个 Python 的内置异常是 ImportError，它会在你试图导入一个模块并且失败的时候抛出

try:
  import chardet
except ImportError:
  chardet = None

  你从不声明这个 multiple 变量，你只是给它赋值了。这样就可以了，因为 Python 让你那样做。 Python 将不会让你做的是，引用了一个变量，但从不给它赋值。这样的尝试将会抛出一个 NameError

  Python 里面所有的名称都是区分大小写的：变量名、函数名、类名、模块名称、异常名称。如果你可以获取它、设置它、调用它、构建它、导入它、或者抛出它，那么它就是区分大小写的。

  Python 模块是对象，并且有几个有用的属性。在你编写它们的时候，通过包含一个特殊的仅在你从命令行运行 Python 文件的时候执行的代码块，你可以使用这些属性容易地测试你的模块  if __name__ == '__main__':

  模块是对象，并且所有模块都有一个内置的属性 __name__。一个模块的 __name__ 属性取决于你怎么来使用这个模块。如果你 import 这个模块，那么 __name__ 就是这个模块的文件名，不包含目录的路径或者文件的扩展名。
  但是你也可以当作一个独立的程序直接运行这个模块，那样的话 __name__ 将是一个特殊的默认值 __main__。

   Python 不支持内嵌的赋值，所以没有机会出现你本以为在做比较而且意外的写成赋值的情况

python的数据类型：
   	简单数据类型：
   	 None
   	 Boolean 
   	 	true false
   	 	在布尔类型上下文环境中，非零整数为真；零为假
   	 string

   	 number (math模块)
   	 	int
   	 	float(通过是否有小数点来区分整形和浮点型 浮点数精确到小数点后 15 位。整数可以任意大。Python 3 只有一种整数类型)
   	 	分数  import fraction;a=fractions.Fraction(2,3)
   	 	Python 并不支持无限精度。tan(π / 4) 将返回 1.0，而不是 0.99999999999999989

   	 Byte
   	复杂数据类型：list tuple dictionary set
   	类型的相互转换
   	可以使用 type() 函数来检测任何值或变量的类型

当然，还有更多的类型。在 Python 中一切均为对象，因此存在像 module［模块］、 function［函数］、 class［类］、 method［方法］、 file［文件］ 甚至 compiled code［已编译代码］ 这样的类型

列表

②	列表可当做以零为基点的数组使用。非空列表的首个元素始终是 a_list[0] 。
③	该 5 元素列表的最后一个元素是 a_list[4]，因为列表（索引）总是以零为基点的。
④	使用负索引值可从列表的尾部向前计数访问元素。任何非空列表的最后一个元素总是 a_list[-1] 
定义列表后，可从其中获取任何部分作为新列表。该技术称为对列表进行 切片

有4种方法可以扩展列表 +  append（） insert（） extend（）
删除列表元素：del，remove，pop（）
不带参数的pop返回被删掉的最后一个元素的值
count() 方法返回了列表中某个特定值出现的次数。
如果你想知道的是某个值是否出现在列表中， in 运算符将会比使用 count() 方法要略快一些。in 运算符总是返回 True 或 False

元组

是不可变的列表。一旦创建之后，用任何方法都不可以修改元素
元组的速度比列表更快。如果定义了一系列常量值，而所需做的仅是对它进行遍历，那么请使用元组替代列表
一些元组可用作字典键（特别是包含字符串、数值和其它元组这样的不可变数据的元组）。列表永远不能当做字典键使用，因为列表可以改变



age = 20
name = 'Swaroop'

print('{0} was {1} years old when he wrote this book'.format(name, age))

---
运算顺序not > and > or
---
range(1,5) 不包含最后一个数

使用函数，必须添加括号，不带括号返回函数本身的描述


global语句用来声明x是全局变量

只有在参数列表后面的的参数可以被赋予默认参数值，即在参数列表中，你不能在没有默认值的参数前有有默认参数值的参数。
这是因为值按位置分配给参数。例如，def func(a, b=5)是有效的，而def func(a=5, b)是无效的。

  如果你有一些有许多参数的函数，您想要指定参数中的一些，那么，你可以通过为参数命名来为它们赋值——这叫做参数关键字——我们使用名称(关键字)而不是位置(我们一直使用的)来指定函数的参数。 	

当我们声明一个星号的参数，如*param，那么从这一点开始到结束的所有位置的参数都被收集到一个叫param的元组中。

同样,当我们声明一个双星参数，如**param，那么人那一点开始到结束的所有关键字参数都被收集到一个叫param的字典中

我们可以使用函数的__doc__(注意，双下划线)属性(属于名字的)访问函数的文档字符串

sys模块包含了与Python解释器和其环境即system系统有关的函数。

每个对象都有默认属性，可以用dir（）列出其所有属性，方法，类

导入一个模块是一个相对昂贵的事情，所以Python做 了一些技巧使它更快。一种方法是创建扩展名为.pyc的字节编译文件，是Python将程序转换成的一种中间形式。(记得在Python如何工作的[简介部分)(#介绍))。当你下次从一个不同程序导入模块时，这种.pyc文件是有很用的--它将快得多，因为导入模块一部分需要的处理已经完成。同时，这些字节编译的文件是独立于平台的。

程序的层次结构。变量通常在函数内部。函数和全局变量通常在模块内部

包只是模块的文件夹，使用一个特殊的__init__.py 文件，指示Python，这个文件夹是特殊的，因为它包含Python模块。

就像函数是可重用的部分的程序一样，模块也是可重用的程序。包是组织模块的另一个层次结构。来自Python的标准库，是包和模块的集合中

在字典中的一对键和值是通过使用冒号指定的，如，d = {key1 : value1, key2 : value2 }

列表、元组和字符串都序列的一个实例

集合是简单对象的无序集合，用于一个集合中对象的存在比它的顺序或发生多少次更重要的时候。

import py_compile
py_compile.compile('1.py')

raw_input()获取到的是字符串，不是数字

print()函数在屏幕上自动换行打印文本。我们是通过指定end=''禁止产生新行
Python提供了一个标准的模块称为pickle，使用它你可以在一个文件中存储任何的Python对象
import pickle
 
# 我们将要存储对象的文件名
shoplistfile = 'shoplist.data'
# 购物清单
shoplist = ['苹果', '芒果', '胡萝卜']
 
# 定到文件
f = open(shoplistfile, 'wb')
pickle.dump(shoplist, f) # 把对象倒入一个文件
f.close()
 
del shoplist # 释放shoplist变量
 
# 从仓库读回
f = open(shoplistfile, 'rb')
storedlist = pickle.load(f) # 从文件载入对象
print(storedlist)



b=[1,2,3]
a=b (a和b将有相同的id号)
c=b[:]（c将是b的一个拷贝，跟b有不同的id号

with open("poem.txt") as f:
    for line in f:
        print(line, end='')

warnings.warn()


a=1,2,3 (tuple的括号可以省略)
a,b=(1,2)
a,b=b,a(快速交换2个变量的值)

如果您想要使用x[key]索引操作你的类(就像你用在列表和元组中使用的)，那么你所要做的就是实现__getitem__()的方法

*前缀在args变量前，所有额外的传递给函数的参数存储作为元组的args 中。如果使用**前缀，额外的参数将被认为是键/值对的字典。

assert 0>1 将会返回AssertionError

如果你需要指定没有经过像转义字符一样进行处理的字符串，那么，你需要通过对字符串前加前缀r或R来指定一个原始的字符串


+连接字符串
*
len（）
max（）
min（）
in  not in
---------------
t1=['name','age']
t2=['bob','12']
t3=zip(t1,t2)
t3.__next__()

dic.keys()
dic.values()
dic.items()

http://docs.python.org/3.2/library/

python debug

深拷贝与浅拷贝
两种拷贝，跟源内容都是完全独立的


变量名仅仅是物理地址空间的一个引用
标签和内容，标签可以有多个


(lambda x,y:x+y)(2,3)
元组作为参数，需要显式用*指明，字典用**指明

序列处理函数 filter() map() reduce() zip()
switch功能可以通过字典和lambada来实现
 func={"+":(lambda x,y:x+y),"-":(lambda x,y:x-y)}

 -----------
 os：
 mkdir mkdirs(-pv) rmdir listdir getcwd chdir walk

 os.system()=subprocess.call()
 os.popen()=subprocess.check_output()


import as

=============


database（mysql,mongodb)

round(1.2345, 3) -> 1.235


前端
	bootstrap
	jquery
	angularjs
后端
	nodejs

PEP: python enhanchment proposal

PyPI: python package index


doctest.testmod()
pydoc <module>
    -g graphic
    -b browser

heapq.nlargest|nsmallest
heapq: a normal list whose first element is always smallest

#TODO
sorted set

create a instance without invoking init
    Date.__new__(Date)

#TODO
iterator and generator
    iterator is a stream of data 
    generator is a coroutine

iter(callable, sentinel): callable is called until return sentinel

open('file', 'xt'): write data to a file only if it doesn't exist
    mode 'a' : append

float('inf'|'-inf','nan') (正负无穷和非实数)

it is good programming practice to not use mutable objects as default values. Instead, use None as the default value and inside the function, check if the parameter is None and create a new list/dictionary whatever if it is

Parameters are defined by the names that appear in a function definition, whereas arguments are the values actually passed to a function when calling it

inspect module : get usefull information from live python objects

embedding and extending

OrderedDict() keyword argument is not recommanded because their
insertion order is arbitrary

why weakref
    if you want to trace a object ,you may create a strong reference to it, but the object may not be 'gc'ed if you forget to delete the reference, also circlue reference.



class create procedure
    1. determin the metaclass
    2. prepare a namespce for it , default dict()   __prepare__
    3. execute the class declare body
    4. create the new class ; __new__

raise Exception from none : suppress the original exception in chained context

__path__ : internal module search path

nonlocal

__file__ :always return absolute path of file
__iter__, __next__

__index__: should return an int, bin(object)

list comprehension 

sorted() , squence.sort()


name mangling 
obj._Class__private_attr

__slots__
    instead of each instance consisting a dictionary, instances are built
    around a fix size array, much like tuple or list , save a lot of space
    but you can no longer add new attribute to them

data descriptor
	@property

nono-data descriptor
    staticmethod
	classmethod


add(int:x + int:y) -> int:
 
unicodedata.normalize()

import pkgutil
data = pkgutil.get_data(__package__, 'somedata.dat') -> raw

importlib.import_module('.b', __package__) -> from . import b


file
================================
os.path.getsize
mmap.mmap(fd, size, access=access)
os.path.exists
os.path.getatime
os.path.isdir()
os.listdir()
sys.getfilesystemencoding()


socket
===============================

Of the various forms of IPC, sockets are by far the most popular. On any given platform, there are likely to be other forms of IPC that are faster, but for cross-platform communication, sockets are about the only game in town.

There’s actually 3 general ways in which this loop could work - dispatching a thread to handle clientsocket, create a new process to handle clientsocket, or restructure this app to use non-blocking sockets, and mulitplex between our “server” socket and any active clientsockets using select. More about that later. The important thing to understand now is this: this is all a “server” socket does. It doesn’t send any data. It doesn’t receive any data. It just produces “client” sockets. Each clientsocket is created in response to some other “client” socket doing a connect() to the host and port we’re bound to. As soon as we’ve created that clientsocket, we go back to listening for more connections. The two “clients” are free to chat it up - they are using some dynamically allocated port which will be recycled when the conversation ends.

send and recv operate on the network buffers. They do not necessarily handle all the bytes you hand them (or expect from them), because their major focus is handling the network buffers. In general, they return when the associated network buffers have been filled (send) or emptied (recv). They then tell you how many bytes they handled. It is your responsibility to call them again until your message has been completely dealt with.

When a recv returns 0 bytes, it means the other side has closed (or is in the process of closing) the connection

But if you plan to reuse your socket for further transfers, you need to realize that there is no EOT on a socket. I repeat: if a socket send or recv returns after handling 0 bytes, the connection has been broken. If the connection has not been broken, you may wait on a recv forever, because the socket will not tell you that there’s nothing more to read (for now).

use socket.setblocking(0) to make it non-blocking.



a = {}
b = enumerate(a)
type(b) --> enumerat

=========
pathlib



=================



eval(source[, globals[, locals]]) -> value
    evaluate the source in the context of globals and locals

random.randint(start,stop) : include both end points
random.choice(container)
random.randrange()


range(start, stop[, step])

time.ctime()
time.localtime()
time.mktime(datetime.datetime(2016, 01, 10).timetuple()) #return timestamp

'dump' to a file object and 'dumps' to a string

descriptor
    staticmethod
    classmethod
    __slots__
    property

#TODO
hide http server version

dict((('a','b'),)) --> {'a':'b'} 
dict(a='b') --> {'a':'b'}
dict.update(a=10)
dict.update({'key':10})

__import__('str') --> import module
importlib.import_module('str')
Definition:  importlib.import_module(name, package=None)
Docstring:
Import a module.

The 'package' argument is required when performing a relative import. It
specifies the package to use as the anchor point from which to resolve the
relative import to an absolute import.

from __future__ import absolute_import
from __future__ import division, unicode_literals

module is a big dict, you can insert new attr into it
__builtin__.end = None

sys.version

operator
functools
itertools

brctl controlled br will missing after reboot


any(iterable object) --> return true if any bool(x) is true
all(iterable)  --> return true if all bool(x) is true

tuple(dict) --> (key1,key2...)
tuple(set) --> a tuple

sys.modules --> return a dict of all loaded modules

b = b'string' 
a = b.decode('utf-8')
c = a.encode('utf-8')

bytes <-(encode|decode)-> string

sys.getdefaultencoding()
sys.getfilesystemencoding()

'unicode'是python内部编码, 而'utf-8'是一种编码方式

bytearray(length) --> builtin
list slice rules   a_list[start:stop:step]  (not include stop, start default to 0)
c=[1,2,3]  b=c[::] (copy)  b=c[::-1](reverse copy)

from collections import Counter ; c=Counter('hello,world')
c.most_common(3) ; c just like a dictionary

sh,purl,docopt,when module

@property
def attr()
@attr.setter
@attr.deleter

eval compile exec
os.execvp(program,args) 
os.spawnvp
os.fork()  daemon

while/for, else: when loop is normally done then run else branch

ansible like automation tools 
    client:
        argparse
        threading
        xmlrpc_client
        getpass
        
    server:
        xmlrpc_server


minimal openstack
    ministack
        api
        compute library
            compute.driver()
                kvm
                docker
            network.driver
                bridge+dhcp mq.driver 
                rabbit
            dashboard(flask)

        client script
            argparse,cmd






callable = deco(callable), deco is callable 
    deco can be function or class
    callable can also be function or class



编译
    静态编译
        c
    动态编译
        字节码
        JIT
    交叉编译
        在特定硬件架构上编译适用于另外硬件架构的程序


bin: return the binary representation of an int or long number
bool() return True if argument are true
issubclass(str,basestring) --> True
callable(object) --> True of False
any(sequence) --> True if any is True
all(sequence) --> True if all is True
chr(int) --> return the charactor of the ascii table which has right serial number
cmp(x,y) --> -1, 0, 1 : compare x and y
vars([object]) -> dictionary
    Without arguments, equivalent to locals().
    With an argument, equivalent to object.__dict__.

__all__   __path__  __file__ __name__ __package__ __doc__

raw_input()   str_to_list
file.read() --> string
file.readliens() --> list
file.readline() --> string per line
file is a iterator

textwrap.fill(doc, width=40)

linux 系统调优

cpu指令集
API ABI

cgroup
进程绑定

PCB, TCB

内存分页，多级页表
进程，线程，协程
堆，栈，帧

栈的3种含义

超线程
微线程


epoll kqueue



# pdb

pdb.set_trace()  : set breakpoint
pdb.pm()  : latest trace_back
pdb.run('module.func()')
python -m pdb script.py
l: list
p: print
r: run until current function return
a: show current funciton args
c: continue run until get another breakpoint
n: run until next line
j <line number> 


============

# store image into Redis
import redis
r =  redis.StrictRedis()
img = open("/path/to/img.jpeg","rb").read()
r.set("bild1",img)
---------------
python on mac os
    built_in module
        /System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7
    third_party module
        /Library/Python/2.7/site-packages
    dynamic loaded
        /Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/lib-dynload

-------------

os.walk('dir') --> (root, dirs, files)


import sys
reload(sys)
sys.setdefaultencoding('utf-8')

pinject
nose
unittest


requests.get(url, params=<dict>, headers=<dict>, data=<string>)

django middleware
django.conf.setting 


r=requests.get()
r.request.headers
r.json()
------------------
ipython autoload
    %reload_ext autoreload
    %autoreload 2
----------------

you can import a decorator then apply it to a function declaration

decorator chain
multi_level inherance


from test.a import * 
(定义__all__) 只会导入定义的属性
(没定义__all__)只会导入__init__.py
__all__ ,__file__ 需要显式定义


# how to test if multiple item in same container
item_set = set(item_list)
container_set = set(container)
if item_set.issubset(container_set): 
    return True


# set
#
a | b : 并集
a & b : 交集
a ^ b : 对称差集
a - b : b相对于a的差集


Exception.args

a._A__private()

random.seed(a=None)
# initialize  internal state from hashable object
a  = 10 if True else 100

from module import * :
# will not be imported
    _a 
    __a 

import module:
    module._a
    module.__a


# what information stored in special attribute
__dict__ : only store private attribute, no method
----------------

new_list = sorted(a_dict.iteritems(), key=lambda d:d[0]) 
    dict to sorted list

string.punctation : 所有的标点符号

--------------

bytes解码过后成为string,string编码后成为bytes
unicode 为python的内部编码
s = '中文' , 解释器会用默认编码存储一串bytes

m  = hashlib.md5()
m.update('hello')
m.update(' world')
m.hexdigest()
--> '5eb63bbbe01eeed093cb22bb8f5acdc3'
hashlib.md5('hello world').hexdigest()
--> '5eb63bbbe01eeed093cb22bb8f5acdc3'


from shutil import make_archive
name = os.path.expanduser(os.path.join('~', 'myarch'))
root_dir = os.path.expanduser(os.path.join('~','.ssh'))
make_archive(name, 'gztar', root_dir)



from cStringIO import StringIO
# python3  from io import StringIO
a = StringIO()
a.write('first line\n')
# a.seek(0)
print >>a, 'second line\n')
print a.getvalue()
a.close()
---------------

shelve module  不一致问题
-------- 


